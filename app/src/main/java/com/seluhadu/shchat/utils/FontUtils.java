package com.seluhadu.shchat.utils;import android.content.Context;import android.graphics.LinearGradient;import android.graphics.Shader;import android.graphics.Typeface;import android.graphics.drawable.Drawable;import android.graphics.drawable.PaintDrawable;import android.graphics.drawable.ShapeDrawable;import android.graphics.drawable.shapes.RectShape;import java.lang.reflect.Field;import java.util.HashMap;import java.util.Map;public class FontUtils {    private static Map<String, Typeface> result = new HashMap<>();    public static Typeface getFont(Context context, String fontName) {        if (result.containsKey(fontName)) {            return result.get(fontName);        } else {            Typeface typeface = Typeface.createFromAsset(context.getAssets(), fontName);            result.put(fontName, typeface);            return typeface;        }    }    public static void overrideFont(Context context, String defaultFont, String overrideFont) {        try {            Typeface typeface = Typeface.createFromAsset(context.getAssets(), overrideFont);            Field field = Typeface.class.getDeclaredField(defaultFont);            field.setAccessible(true);            field.set(null, typeface);        } catch (NoSuchFieldException | IllegalAccessException e) {            e.printStackTrace();        }    }    public static Drawable drawable(final int[] colors, final float[] position, final AngleGradient angleGradient) {        ShapeDrawable.ShaderFactory shaderFactory = new ShapeDrawable.ShaderFactory() {            @Override            public Shader resize(int width, int height) {                AngleCoordinate a = AngleCoordinate.getAngle(width, height, angleGradient);                return new LinearGradient(a.x1, a.y1, a.x2, a.y2, colors, position, Shader.TileMode.REPEAT);            }        };        PaintDrawable paintDrawable = new PaintDrawable();        paintDrawable.setShaderFactory(shaderFactory);        paintDrawable.setShape(new RectShape());        return paintDrawable;    }    public static Drawable drawable(final int[] colors, final float[] position) {        return drawable(colors, position, AngleGradient.LEFT_BOTTOM_TO_RIGHT_TOP);    }    public static Drawable drawable(final int[] colors, AngleGradient angleGradient) {        float[] positions = new float[colors.length];        for (int i = 0; i < positions.length; i++) {            positions[i] = i * (float) 1 / positions.length - 1;            positions[positions.length -1] = 1;        }        return drawable(colors, positions, angleGradient);    }    public static Drawable drawable(final int[] colors) {        return drawable(colors, AngleGradient.LEFT_BOTTOM_TO_RIGHT_TOP);    }    public static class AngleCoordinate {        float x1, x2, y1, y2;        public static AngleCoordinate getAngle(float width, float height, AngleGradient angleGradient) {            AngleCoordinate a = new AngleCoordinate();            switch (angleGradient) {                case LEFT_TO_RIGHT:                    a.x2 = width;                    break;                case RIGHT_TO_LEFT:                    a.x1 = width;                    break;                case BOTTOM_TO_TOP:                    a.y1 = height;                    break;                case TOP_TO_BOTTOM:                    a.y2 = height;                    break;                case LEFT_BOTTOM_TO_RIGHT_TOP:                    a.x2 = width;                    a.y1 = height;                    break;                case LEFT_TOP_TO_RIGHT_BOTTOM:                    a.y2 = height;                    a.x2 = width;                    break;                case RIGHT_BOTTOM_TO_LEFT_TOP:                    a.x2 = width;                    a.y1 = height;                    break;                case RIGHT_TOP_TO_LEFT_BOTTOM:                    a.x1 = width;                    a.y2 = height;                    break;            }            return a;        }    }    public enum AngleGradient {        LEFT_TO_RIGHT,        RIGHT_TO_LEFT,        TOP_TO_BOTTOM,        BOTTOM_TO_TOP,        LEFT_BOTTOM_TO_RIGHT_TOP,        RIGHT_TOP_TO_LEFT_BOTTOM,        RIGHT_BOTTOM_TO_LEFT_TOP,        LEFT_TOP_TO_RIGHT_BOTTOM    }}